- [1. 冒泡排序](#1-冒泡排序)
  - [1.1. 设计目的](#11-设计目的)
  - [1.2. 设计任务](#12-设计任务)
  - [1.3. 原理框图及说明](#13-原理框图及说明)
  - [1.4. 主要电路说明、元件选择及参数计算](#14-主要电路说明元件选择及参数计算)
  - [1.5. 复位与振荡电路](#15-复位与振荡电路)
  - [1.6. 液晶电路](#16-液晶电路)
  - [1.7. 按键电路](#17-按键电路)
  - [1.8. 输出监测电路](#18-输出监测电路)
  - [1.9. 总电路](#19-总电路)
  - [1.10. 软件设计思路及主流程图](#110-软件设计思路及主流程图)
- [2. 电子密码锁](#2-电子密码锁)
  - [2.1. 设计任务要求](#21-设计任务要求)
  - [2.2. 设计方案及论证](#22-设计方案及论证)
    - [2.2.1. 实验方案比较](#221-实验方案比较)
    - [2.2.2. 原理图](#222-原理图)
    - [2.2.3. 运行效果图](#223-运行效果图)
  - [2.3. 操作注意](#23-操作注意)
    - [2.3.1. 源码](#231-源码)

>**[The Author's E-mail](http://www.thdong.top/index.php/start-page.html)**

# 1. 冒泡排序

单片机 + LCD1602实现冒泡排序

## 1.1. 设计目的

1. 通过按键的功能复用，输入一组两位以上的数据，一组数据不少于6个；
2. 通过按键控制数字从大到小或者从小到大排序；
3. 在1602液晶上显示冒泡排序。

## 1.2. 设计任务

单片机实现冒泡排序：
1. 液晶提示用户输入，一旦检测到输入即在液晶上显示当前输入的数字。
2. 通过10个数字按键输入数据，每输入两个数字会有空格隔开以区分位数。
3. 代码低耦合，可以通过修改参数改变输入数据位数以及个数。
4. 单片机计算后由用户按键选择排序顺序显示在液晶上。

## 1.3. 原理框图及说明

![](https://ythdong.gitee.io/blog_image/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E5%8D%95%E7%89%87%E6%9C%BA1.png)

1. 电源部分：由于没有硬件实物只进行了仿真，所以电源电路在Proteus中并未画出，实物应是5V的电源电路；
2. 数字按键：10个数字按键提供给用户作为数据输入源使用；
3. 液晶电路：液晶实时显示输入数据以及显示排序后的数据；
4. 输入检测：输入检测电路接到了P1^7口，用于在液晶显示输入提示时检测用户是否开始按键输入，此处通过反相器 + 二极管串联在10个数字按键上，一旦用户输入就能检测到，然后液晶开始显示实时输入数据，并且10个数字按键之间由于二极管的单向导通性不会相互影响。
5. 排序选择：在用户输入结束之后已经完成了冒泡排序，最后通过用户选择默认排序还是反向排序显示到液晶上。

## 1.4. 主要电路说明、元件选择及参数计算

对于晶振电路和复位电路中电容、电阻以及晶振频率的选择参考福讯公司提供的实物参数，也就是学校的那个实物，方便以后实物操作，其余的元件我只用到了按键、二极管、液晶、反向器均没有选择的余地，大都是有什么能用的就用什么。

## 1.5. 复位与振荡电路

复位电路如下图，由C3和R1构成。由于51单片机为低电平复位，图示电路利用电容的特性，在刚刚外加5V电源时RST脚的电压为低。时间常数=RC=38mS，满足芯片复位要求。由于电压为5V，可选择耐压的电容即可。

![](https://ythdong.gitee.io/blog_image/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E5%8D%95%E7%89%87%E6%9C%BA2.png)

## 1.6. 液晶电路

![](https://ythdong.gitee.io/blog_image/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E5%8D%95%E7%89%87%E6%9C%BA3.png)

## 1.7. 按键电路

![](https://ythdong.gitee.io/blog_image/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E5%8D%95%E7%89%87%E6%9C%BA4.png)

## 1.8. 输出监测电路

![](https://ythdong.gitee.io/blog_image/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E5%8D%95%E7%89%87%E6%9C%BA5.png)

这里的按键输入检测主要是为了让液晶及时地实时地显示用户输入的数据，因为所有的按键都是接地的，一旦被按下则电平为0，并且按键检测电路使用了反相器 + 二极管串联的方法，在代码中一开始我就将P1^7口初始化为0，这样当数字按键被按下时低电平经过反相器变成高电平通过二极管到达P1^7口为1则标志着用户已经开始输入了，此时液晶要显示数据。

## 1.9. 总电路

![](https://ythdong.gitee.io/blog_image/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E5%8D%95%E7%89%87%E6%9C%BA6.png)

## 1.10. 软件设计思路及主流程图

![](https://ythdong.gitee.io/blog_image/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E5%8D%95%E7%89%87%E6%9C%BA7.png)

# 2. 电子密码锁

## 2.1. 设计任务要求

1.通过该电路的焊接，应熟练掌握焊接技术；
2.掌握MCS51的工作原理，基于C51的程序设计和程序下载方法。
3.以此最小系统板作为控制核心，设计简易密码锁。
4.简易密码锁要求有密码设置功能、密码输入开锁功能、输入错误报警功能、输入错误锁屏功能等。
5.开发板有六个按键，如何设置各个按键的功能；如何用数码管进行显示等。

## 2.2. 设计方案及论证

### 2.2.1. 实验方案比较

基于52单片机的简易密码锁有多种实现方案，比如使用数码管可以做，使用点阵可以做，使用1602和12864液晶都可以做，关键在于用户界面，我的单片机只有数码管和1602液晶，数码管只有四位，并且只能显示数字，这不仅对密码锁用户很不友好，而且只有四位密码安全性不高所以最终选择使用液晶。
对于二者之间的区别，实际上只有界面的不同，液晶可以显示16x2的英文，这可以用来设置一些提示，而数码管只能显示数字，通过对应关系来判断此时密码锁的状态，比较麻烦，对于密码的输入与存储其实大同小异，我在创建了两个数组，一个用来存储初始设置的密码，同时也是修改密码存储的数组，而另一个数组则用来存储用户输入的密码，再对二者进行判断密码是否正确。对于实现细节将在后面讲到

### 2.2.2. 原理图

![](https://img-blog.csdnimg.cn/20190515085829352.png)

![](https://img-blog.csdnimg.cn/20190515085841176.png)

![](https://img-blog.csdnimg.cn/20190515085850850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyODQyNzg2,size_16,color_FFFFFF,t_70)

### 2.2.3. 运行效果图

如下提示输入密码

![](https://img-blog.csdnimg.cn/20190515085918705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyODQyNzg2,size_16,color_FFFFFF,t_70)

## 2.3. 操作注意

* 我这密码锁比较简单，只用到了两个按键，实际上只用一个也可以。
* 初始密码为234567，在输入的时候可以长按设置的key1键，这个在你自己的开发板中按键肯定不同，直接拿我的源码估计是用不了，毕竟每块开发板的接口对应的资源不一样，你需要把按键以及接口以及其他需要更改的内容重新定义就可以，程序的核心是可以不用修改的。
* 修改密码在输入密码正确的后的2.5s内长按我定义的key2会进入改密码的界面，同输入密码一样，使用key1键，单片机会按顺序一直输入密码，也可以一个一个地输入，改密之后会再次进入输密码验证如此一直循环，当然这只是一个象征意义，距离真正的密码锁还比较远，我只是把核心功能做出来了，其他外设，比如提示灯、继电器、蜂鸣器、锁屏等等比较简单的东西大家自己去琢磨吧。


### 2.3.1. 源码

代码详见 [Gitee~Blog-Image](https://ythdong.gitee.io/blog_image/%E4%BB%A3%E7%A0%81/%E7%94%B5%E5%AD%90%E5%AF%86%E7%A0%81%E9%94%81.html)
<hr>

>代码里面那个yanchi函数实际上就是延时函数，因为在我自己的机子上我把它写进了reg52的库里，所以代码中没有函数声明
